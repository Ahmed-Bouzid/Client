/**
 * ðŸ’¬ MessagingBubble - Chat moderne client â†” serveur
 *
 * Design inspirÃ© de chat-bubble (21st.dev)
 * - Bulle flottante avec animation
 * - Conversation style "chat bubbles"
 * - Suggestions de messages prÃ©dÃ©finis (pas d'input)
 */

import React, {
	useState,
	useEffect,
	useRef,
	useMemo,
	useCallback,
} from "react";
import {
	View,
	Text,
	TouchableOpacity,
	StyleSheet,
	Animated,
	Modal,
	ScrollView,
	Dimensions,
	ActivityIndicator,
	Vibration,
	Platform,
} from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import { Ionicons } from "@expo/vector-icons";
import { messageService } from "../../services/messageService";
import { useSocketClient } from "../../hooks/useSocketClient";
import { getRestaurantId } from "../../utils/getRestaurantId";

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window");

// ðŸŽ¨ Design System
const COLORS = {
	primary: "#6366f1", // Indigo
	primaryLight: "#818cf8",
	primaryDark: "#4f46e5",
	sent: "#6366f1", // Messages envoyÃ©s (client)
	received: "#f1f5f9", // Messages reÃ§us (serveur)
	receivedText: "#1e293b",
	background: "#ffffff",
	surface: "#f8fafc",
	border: "#e2e8f0",
	text: "#1e293b",
	textMuted: "#64748b",
	textLight: "#94a3b8",
	success: "#22c55e",
	chipBg: "#f1f5f9",
	chipBgHover: "#e2e8f0",
};

// CatÃ©gories avec Ã©mojis
const CATEGORY_CONFIG = {
	service: { emoji: "ðŸ½ï¸", label: "Service" },
	commande: { emoji: "ðŸ“", label: "Commande" },
	paiement: { emoji: "ðŸ’³", label: "Paiement" },
	autre: { emoji: "ðŸ’¬", label: "Autre" },
};

// ðŸŽ¯ Messages prÃ©dÃ©finis par dÃ©faut (fallback si API Ã©choue)
const DEFAULT_PREDEFINED_MESSAGES = [
	{
		_id: "default-1",
		text: "Pourrais-je avoir de l'eau ?",
		category: "service",
	},
	{
		_id: "default-2",
		text: "L'addition s'il vous plaÃ®t",
		category: "paiement",
	},
	{
		_id: "default-3",
		text: "Pourrais-je avoir des couverts ?",
		category: "service",
	},
	{
		_id: "default-4",
		text: "Y a-t-il du wifi ?",
		category: "autre",
	},
	{
		_id: "default-5",
		text: "OÃ¹ sont les toilettes ?",
		category: "autre",
	},
	{
		_id: "default-6",
		text: "Pourrais-je modifier ma commande ?",
		category: "commande",
	},
	{
		_id: "default-7",
		text: "Puis-je payer par carte ?",
		category: "paiement",
	},
	{
		_id: "default-8",
		text: "Pourrais-je avoir des serviettes ?",
		category: "service",
	},
];

const MessagingBubble = ({ reservationId, clientId, clientName, style }) => {
	// WebSocket
	const [restaurantId, setRestaurantId] = useState(null);
	const { isConnected, on, off } = useSocketClient(restaurantId);

	// Ã‰tats
	const [isVisible, setIsVisible] = useState(false);
	const [isOpen, setIsOpen] = useState(false);
	const [conversation, setConversation] = useState([]);
	const [predefinedMessages, setPredefinedMessages] = useState([]);
	const [unreadCount, setUnreadCount] = useState(0);
	const [loading, setLoading] = useState(false);
	const [sending, setSending] = useState(null); // ID du message en cours d'envoi
	const [selectedCategory, setSelectedCategory] = useState(null);
	const conversationRef = useRef(null);

	// Animations
	const bubbleScale = useRef(new Animated.Value(0)).current;
	const bubbleOpacity = useRef(new Animated.Value(0)).current;
	const modalOpacity = useRef(new Animated.Value(0)).current;
	const pulseAnim = useRef(new Animated.Value(1)).current;

	// Init restaurantId
	useEffect(() => {
		const init = async () => {
			const id = await getRestaurantId();
			setRestaurantId(id);
		};
		init();
	}, []);

	// WebSocket - RÃ©ponses serveur
	useEffect(() => {
		if (!isConnected || !reservationId) return;

		const handleServerResponse = (event) => {
			if (event.data?.reservationId !== reservationId) return;

			setConversation((prev) => [
				...prev,
				{
					type: "server",
					text: event.data.responseText,
					serverName: event.data.serverName || "Serveur",
					createdAt: new Date().toISOString(),
					_id: event.data.responseId,
				},
			]);

			if (!isOpen) {
				setUnreadCount((prev) => prev + 1);
			}

			if (Platform.OS !== "web") {
				Vibration.vibrate([0, 100]);
			}

			setTimeout(() => {
				conversationRef.current?.scrollToEnd({ animated: true });
			}, 100);
		};

		// Nouveau : Ã©couter les mises Ã  jour de statut (message lu)
		const handleMessageStatus = (event) => {
			if (event.type === "read" && event.data?.messageId) {
				console.log("âœ… Message marquÃ© comme lu:", event.data.messageId);
				// Mettre Ã  jour le statut dans la conversation
				setConversation((prev) =>
					prev.map((msg) =>
						msg._id === event.data.messageId
							? { ...msg, status: "read", readAt: event.data.readAt }
							: msg,
					),
				);
			}
		};

		on("server-response", handleServerResponse);
		on("message-status", handleMessageStatus);
		return () => {
			off("server-response", handleServerResponse);
			off("message-status", handleMessageStatus);
		};
	}, [isConnected, reservationId, isOpen, on, off]);

	// Charger conversation existante
	useEffect(() => {
		if (!reservationId) return;

		const loadConversation = async () => {
			const data = await messageService.fetchConversation(reservationId);
			setConversation(data);
			const serverUnread = data.filter(
				(m) => m.type === "server" && m.status !== "read",
			).length;
			setUnreadCount(serverUnread);
		};

		loadConversation();
	}, [reservationId]);

	// Animation apparition bulle + charger messages prÃ©dÃ©finis
	useEffect(() => {
		const timer = setTimeout(() => {
			setIsVisible(true);
			Animated.parallel([
				Animated.spring(bubbleScale, {
					toValue: 1,
					friction: 6,
					tension: 100,
					useNativeDriver: true,
				}),
				Animated.timing(bubbleOpacity, {
					toValue: 1,
					duration: 400,
					useNativeDriver: true,
				}),
			]).start();
			startPulseAnimation();
			// ðŸŽ¯ Charger les messages prÃ©dÃ©finis dÃ¨s l'apparition de la bulle
			loadMessages();
		}, 2500);

		return () => clearTimeout(timer);
	}, [loadMessages]);

	const startPulseAnimation = () => {
		Animated.loop(
			Animated.sequence([
				Animated.timing(pulseAnim, {
					toValue: 1.08,
					duration: 1200,
					useNativeDriver: true,
				}),
				Animated.timing(pulseAnim, {
					toValue: 1,
					duration: 1200,
					useNativeDriver: true,
				}),
			]),
		).start();
	};

	// Charger messages prÃ©dÃ©finis
	const loadMessages = useCallback(async () => {
		if (predefinedMessages.length > 0) return;
		setLoading(true);
		try {
			const data = await messageService.fetchPredefinedMessages();
			// ðŸŽ¯ Utiliser les messages par dÃ©faut si l'API retourne vide
			if (!data || data.length === 0) {
				console.log("âš ï¸ API vide, utilisation des messages par dÃ©faut");
				setPredefinedMessages(DEFAULT_PREDEFINED_MESSAGES);
			} else {
				setPredefinedMessages(data);
			}
		} catch (error) {
			console.error("Erreur chargement messages:", error);
			// ðŸŽ¯ En cas d'erreur, utiliser les messages par dÃ©faut
			setPredefinedMessages(DEFAULT_PREDEFINED_MESSAGES);
		} finally {
			setLoading(false);
		}
	}, [predefinedMessages.length]);

	// Ouvrir le chat
	const openChat = useCallback(() => {
		setIsOpen(true);
		setUnreadCount(0);

		Animated.timing(modalOpacity, {
			toValue: 1,
			duration: 200,
			useNativeDriver: true,
		}).start();

		setTimeout(() => {
			conversationRef.current?.scrollToEnd({ animated: false });
		}, 100);
	}, []);

	// Fermer le chat
	const closeChat = useCallback(() => {
		Animated.timing(modalOpacity, {
			toValue: 0,
			duration: 150,
			useNativeDriver: true,
		}).start(() => {
			setIsOpen(false);
			setSelectedCategory(null);
		});
	}, []);

	// Envoyer un message
	const sendMessage = useCallback(
		async (message) => {
			if (!reservationId || !clientId || sending) return;

			setSending(message._id);

			if (Platform.OS !== "web") {
				Vibration.vibrate(30);
			}

			try {
				// ðŸŽ¯ Pour les messages par dÃ©faut, on les ajoute juste localement
				// car le backend n'a pas ces IDs en DB
				const isDefaultMessage = message._id.toString().startsWith("default-");

				if (isDefaultMessage) {
					// Ajouter directement Ã  la conversation sans appeler l'API
					setConversation((prev) => [
						...prev,
						{
							type: "client",
							text: message.text,
							createdAt: new Date().toISOString(),
							_id: `local-${Date.now()}`,
							status: "sent",
						},
					]);

					// TODO: ImplÃ©menter l'envoi rÃ©el via WebSocket ou endpoint dÃ©diÃ©
					console.log("ðŸ“¤ Message local envoyÃ©:", message.text);
				} else {
					// Message prÃ©dÃ©fini de l'API - appel normal
					const result = await messageService.sendMessage({
						predefinedMessageId: message._id,
						reservationId,
						clientId,
						clientName,
					});

					setConversation((prev) => [
						...prev,
						{
							type: "client",
							text: message.text,
							createdAt: new Date().toISOString(),
							_id: result.data?._id || Date.now().toString(),
							status: "sent",
						},
					]);
				}

				setSelectedCategory(null);

				setTimeout(() => {
					conversationRef.current?.scrollToEnd({ animated: true });
				}, 100);
			} catch (error) {
				console.error("Erreur envoi:", error);
			} finally {
				setSending(null);
			}
		},
		[reservationId, clientId, clientName, sending],
	);

	// Messages filtrÃ©s par catÃ©gorie
	const filteredMessages = useMemo(() => {
		if (!selectedCategory) return [];
		return predefinedMessages.filter((m) => m.category === selectedCategory);
	}, [predefinedMessages, selectedCategory]);

	// Grouper les catÃ©gories disponibles
	const availableCategories = useMemo(() => {
		const cats = new Set(predefinedMessages.map((m) => m.category || "autre"));
		return Array.from(cats);
	}, [predefinedMessages]);

	if (!isVisible) return null;

	return (
		<>
			{/* ðŸ”˜ Bulle flottante */}
			<Animated.View
				style={[
					styles.bubbleContainer,
					style,
					{
						opacity: bubbleOpacity,
						transform: [{ scale: Animated.multiply(bubbleScale, pulseAnim) }],
					},
				]}
			>
				<TouchableOpacity
					onPress={openChat}
					activeOpacity={0.9}
					style={styles.bubble}
				>
					<LinearGradient
						colors={[COLORS.primary, COLORS.primaryDark]}
						start={{ x: 0, y: 0 }}
						end={{ x: 1, y: 1 }}
						style={styles.bubbleGradient}
					>
						<Ionicons name="chatbubble-ellipses" size={26} color="#fff" />
					</LinearGradient>
					{unreadCount > 0 && (
						<View style={styles.badge}>
							<Text style={styles.badgeText}>
								{unreadCount > 9 ? "9+" : unreadCount}
							</Text>
						</View>
					)}
				</TouchableOpacity>
			</Animated.View>

			{/* ðŸ’¬ Modal Chat */}
			<Modal
				visible={isOpen}
				transparent
				animationType="none"
				onRequestClose={closeChat}
			>
				<Animated.View style={[styles.modalOverlay, { opacity: modalOpacity }]}>
					<TouchableOpacity
						style={styles.modalBackdrop}
						activeOpacity={1}
						onPress={closeChat}
					/>

					<View style={styles.chatContainer}>
						{/* Header */}
						<View style={styles.header}>
							<View style={styles.headerInfo}>
								<View style={styles.headerAvatar}>
									<Ionicons
										name="restaurant"
										size={20}
										color={COLORS.primary}
									/>
								</View>
								<View>
									<Text style={styles.headerTitle}>Service</Text>
									<Text style={styles.headerSubtitle}>
										{isConnected ? "En ligne" : "Hors ligne"}
									</Text>
								</View>
							</View>
							<TouchableOpacity onPress={closeChat} style={styles.closeBtn}>
								<Ionicons name="close" size={24} color={COLORS.textMuted} />
							</TouchableOpacity>
						</View>

						{/* Conversation */}
						<ScrollView
							ref={conversationRef}
							style={styles.conversation}
							contentContainerStyle={styles.conversationContent}
							showsVerticalScrollIndicator={false}
						>
							{/* Message d'accueil */}
							{conversation.length === 0 && (
								<View style={styles.welcomeContainer}>
									<View style={styles.welcomeIcon}>
										<Ionicons
											name="hand-right"
											size={32}
											color={COLORS.primary}
										/>
									</View>
									<Text style={styles.welcomeTitle}>Besoin d'aide ?</Text>
									<Text style={styles.welcomeText}>
										SÃ©lectionnez un message ci-dessous pour appeler le serveur
									</Text>
								</View>
							)}

							{/* Messages */}
							{conversation.map((msg, idx) => {
								const isClient = msg.type === "client";
								return (
									<View
										key={msg._id || idx}
										style={[
											styles.messageRow,
											isClient
												? styles.messageRowSent
												: styles.messageRowReceived,
										]}
									>
										{!isClient && (
											<View style={styles.avatarSmall}>
												<Ionicons
													name="person"
													size={14}
													color={COLORS.textMuted}
												/>
											</View>
										)}
										<View
											style={[
												styles.messageBubble,
												isClient ? styles.sentBubble : styles.receivedBubble,
											]}
										>
											{!isClient && (
												<Text style={styles.serverName}>
													{msg.serverName || "Serveur"}
												</Text>
											)}
											<Text
												style={[
													styles.messageText,
													isClient ? styles.sentText : styles.receivedText,
												]}
											>
												{msg.text}
											</Text>
											<View style={styles.messageFooter}>
												<Text
													style={[
														styles.messageTime,
														isClient ? styles.sentTime : styles.receivedTime,
													]}
												>
													{new Date(msg.createdAt).toLocaleTimeString("fr-FR", {
														hour: "2-digit",
														minute: "2-digit",
													})}
												</Text>
												{/* Check si message lu (seulement pour messages clients) */}
												{isClient && msg.status === "read" && (
													<Ionicons
														name="checkmark-done"
														size={16}
														color="rgba(255,255,255,0.7)"
														style={{ marginLeft: 4 }}
													/>
												)}
											</View>
										</View>
									</View>
								);
							})}
						</ScrollView>

						{/* Suggestions de messages */}
						<View style={styles.suggestionsContainer}>
							{loading ? (
								<View style={styles.loadingContainer}>
									<ActivityIndicator size="small" color={COLORS.primary} />
								</View>
							) : selectedCategory ? (
								<>
									{/* Header catÃ©gorie sÃ©lectionnÃ©e */}
									<View style={styles.categoryHeader}>
										<TouchableOpacity
											onPress={() => setSelectedCategory(null)}
											style={styles.backBtn}
										>
											<Ionicons
												name="chevron-back"
												size={20}
												color={COLORS.primary}
											/>
										</TouchableOpacity>
										<Text style={styles.categoryTitle}>
											{CATEGORY_CONFIG[selectedCategory]?.emoji}{" "}
											{CATEGORY_CONFIG[selectedCategory]?.label}
										</Text>
									</View>

									{/* Messages de la catÃ©gorie */}
									<ScrollView
										horizontal
										showsHorizontalScrollIndicator={false}
										contentContainerStyle={styles.chipsScroll}
									>
										{filteredMessages.map((msg) => (
											<TouchableOpacity
												key={msg._id}
												style={[
													styles.messageChip,
													sending === msg._id && styles.messageChipSending,
												]}
												onPress={() => sendMessage(msg)}
												disabled={sending !== null}
												activeOpacity={0.7}
											>
												{sending === msg._id ? (
													<ActivityIndicator
														size="small"
														color={COLORS.primary}
													/>
												) : (
													<Text style={styles.chipText}>{msg.text}</Text>
												)}
											</TouchableOpacity>
										))}
									</ScrollView>
								</>
							) : (
								<>
									{/* SÃ©lection de catÃ©gorie */}
									<Text style={styles.suggestionsTitle}>
										Comment puis-je vous aider ?
									</Text>
									<View style={styles.categoriesGrid}>
										{availableCategories.map((cat) => (
											<TouchableOpacity
												key={cat}
												style={styles.categoryChip}
												onPress={() => setSelectedCategory(cat)}
												activeOpacity={0.7}
											>
												<Text style={styles.categoryEmoji}>
													{CATEGORY_CONFIG[cat]?.emoji || "ðŸ’¬"}
												</Text>
												<Text style={styles.categoryLabel}>
													{CATEGORY_CONFIG[cat]?.label || cat}
												</Text>
											</TouchableOpacity>
										))}
									</View>
								</>
							)}
						</View>
					</View>
				</Animated.View>
			</Modal>
		</>
	);
};

const styles = StyleSheet.create({
	// Bulle flottante
	bubbleContainer: {
		position: "absolute",
		bottom: 100,
		right: 20,
		zIndex: 1000,
	},
	bubble: {
		width: 56,
		height: 56,
		borderRadius: 28,
		shadowColor: COLORS.primaryDark,
		shadowOffset: { width: 0, height: 4 },
		shadowOpacity: 0.3,
		shadowRadius: 8,
		elevation: 6,
	},
	bubbleGradient: {
		width: "100%",
		height: "100%",
		borderRadius: 28,
		justifyContent: "center",
		alignItems: "center",
	},
	badge: {
		position: "absolute",
		top: -2,
		right: -2,
		backgroundColor: "#ef4444",
		borderRadius: 10,
		minWidth: 20,
		height: 20,
		justifyContent: "center",
		alignItems: "center",
		paddingHorizontal: 6,
		borderWidth: 2,
		borderColor: "#fff",
	},
	badgeText: {
		color: "#fff",
		fontSize: 11,
		fontWeight: "700",
	},

	// Modal
	modalOverlay: {
		flex: 1,
		backgroundColor: "rgba(0, 0, 0, 0.4)",
		justifyContent: "flex-end",
	},
	modalBackdrop: {
		position: "absolute",
		top: 0,
		left: 0,
		right: 0,
		bottom: 0,
	},

	// Chat container
	chatContainer: {
		backgroundColor: COLORS.background,
		borderTopLeftRadius: 24,
		borderTopRightRadius: 24,
		height: SCREEN_HEIGHT * 0.5,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: -4 },
		shadowOpacity: 0.1,
		shadowRadius: 12,
		elevation: 10,
	},

	// Header
	header: {
		flexDirection: "row",
		alignItems: "center",
		justifyContent: "space-between",
		paddingHorizontal: 20,
		paddingVertical: 16,
		borderBottomWidth: 1,
		borderBottomColor: COLORS.border,
	},
	headerInfo: {
		flexDirection: "row",
		alignItems: "center",
		gap: 12,
	},
	headerAvatar: {
		width: 40,
		height: 40,
		borderRadius: 20,
		backgroundColor: COLORS.surface,
		justifyContent: "center",
		alignItems: "center",
	},
	headerTitle: {
		fontSize: 16,
		fontWeight: "600",
		color: COLORS.text,
	},
	headerSubtitle: {
		fontSize: 12,
		color: COLORS.success,
	},
	closeBtn: {
		padding: 4,
	},

	// Conversation
	conversation: {
		flex: 1,
		paddingHorizontal: 16,
	},
	conversationContent: {
		paddingVertical: 16,
	},

	// Welcome
	welcomeContainer: {
		alignItems: "center",
		paddingVertical: 40,
		paddingHorizontal: 20,
	},
	welcomeIcon: {
		width: 64,
		height: 64,
		borderRadius: 32,
		backgroundColor: COLORS.surface,
		justifyContent: "center",
		alignItems: "center",
		marginBottom: 16,
	},
	welcomeTitle: {
		fontSize: 18,
		fontWeight: "600",
		color: COLORS.text,
		marginBottom: 8,
	},
	welcomeText: {
		fontSize: 14,
		color: COLORS.textMuted,
		textAlign: "center",
		lineHeight: 20,
	},

	// Messages
	messageRow: {
		flexDirection: "row",
		marginBottom: 12,
		alignItems: "flex-end",
	},
	messageRowSent: {
		justifyContent: "flex-end",
	},
	messageRowReceived: {
		justifyContent: "flex-start",
	},
	avatarSmall: {
		width: 28,
		height: 28,
		borderRadius: 14,
		backgroundColor: COLORS.surface,
		justifyContent: "center",
		alignItems: "center",
		marginRight: 8,
	},
	messageBubble: {
		maxWidth: "75%",
		paddingVertical: 10,
		paddingHorizontal: 14,
		borderRadius: 18,
	},
	sentBubble: {
		backgroundColor: COLORS.sent,
		borderBottomRightRadius: 4,
	},
	receivedBubble: {
		backgroundColor: COLORS.received,
		borderBottomLeftRadius: 4,
	},
	serverName: {
		fontSize: 11,
		fontWeight: "600",
		color: COLORS.textMuted,
		marginBottom: 2,
	},
	messageText: {
		fontSize: 15,
		lineHeight: 20,
	},
	sentText: {
		color: "#fff",
	},
	receivedText: {
		color: COLORS.receivedText,
	},
	messageFooter: {
		flexDirection: "row",
		alignItems: "center",
		marginTop: 4,
		alignSelf: "flex-end",
	},
	messageTime: {
		fontSize: 10,
	},
	sentTime: {
		color: "rgba(255, 255, 255, 0.7)",
	},
	receivedTime: {
		color: COLORS.textLight,
	},
	readBadge: {
		width: 18,
		height: 18,
		borderRadius: 9,
		backgroundColor: "#10b981",
		justifyContent: "center",
		alignItems: "center",
		marginLeft: 6,
	},

	// Suggestions
	suggestionsContainer: {
		borderTopWidth: 1,
		borderTopColor: COLORS.border,
		paddingVertical: 16,
		paddingHorizontal: 16,
		backgroundColor: COLORS.surface,
	},
	loadingContainer: {
		paddingVertical: 20,
		alignItems: "center",
	},
	suggestionsTitle: {
		fontSize: 14,
		fontWeight: "500",
		color: COLORS.textMuted,
		marginBottom: 12,
		textAlign: "center",
	},

	// Categories
	categoriesGrid: {
		flexDirection: "row",
		flexWrap: "wrap",
		justifyContent: "center",
		gap: 10,
	},
	categoryChip: {
		flexDirection: "row",
		alignItems: "center",
		backgroundColor: COLORS.background,
		paddingVertical: 12,
		paddingHorizontal: 16,
		borderRadius: 12,
		gap: 8,
		borderWidth: 1,
		borderColor: COLORS.border,
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.05,
		shadowRadius: 2,
		elevation: 1,
	},
	categoryEmoji: {
		fontSize: 18,
	},
	categoryLabel: {
		fontSize: 14,
		fontWeight: "500",
		color: COLORS.text,
	},

	// Category header (when selected)
	categoryHeader: {
		flexDirection: "row",
		alignItems: "center",
		marginBottom: 12,
	},
	backBtn: {
		padding: 4,
		marginRight: 8,
	},
	categoryTitle: {
		fontSize: 14,
		fontWeight: "600",
		color: COLORS.text,
	},

	// Message chips
	chipsScroll: {
		paddingVertical: 4,
		gap: 8,
	},
	messageChip: {
		backgroundColor: COLORS.background,
		paddingVertical: 10,
		paddingHorizontal: 16,
		borderRadius: 20,
		marginRight: 8,
		borderWidth: 1,
		borderColor: COLORS.border,
		minWidth: 60,
		alignItems: "center",
	},
	messageChipSending: {
		backgroundColor: COLORS.chipBgHover,
	},
	chipText: {
		fontSize: 14,
		color: COLORS.text,
	},
});

export default MessagingBubble;
